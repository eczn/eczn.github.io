{"code":0,"data":{"categoryId":"未分类标题","list":[{"id":"test-tsx-article-for-new-version","title":"新版博客测试文章 (.tsx)","author":"eczn","time":"1999-12-31T16:00:02.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"title":"Markdown 快速上手","date":"2017-02-07 02:21:11","intro":"Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯，写文章经常用的到，它可以被编译成HTML，比起直接用HTML写文章，Markdown书写起来更简洁快速，写作体验会好很多。 ","headPic":"http://2.im.guokr.com/YtavWcYpNiA3PDc9nI3VlKABHBwMwev-sVT_rHUQJAjEAQAA_wAAAEpQ.jpg","type":"article","id":"62ca7f2093a59fcbab91ce9ad5fd9c37","appTitle":"","appIcon":"","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","author":"eczn","imgs":[],"tags":[],"time":"2017-02-06T18:21:11.000Z","isDraft":false,"fileDeps":[],"wordCount":1322},{"id":"three-body-emulator","title":"三体运动模拟器","time":"2021-06-16T10:33:00.000Z","author":"eczn","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"is-esm-robust-enough-in-broswer","title":"浏览器内的 ESM 是否已足够强大","author":"eczn","time":"2022-01-04T15:33:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"white-noise-webgl","title":"从白噪声开始学习 WebGL","author":"eczn","time":"2023-03-28T16:34:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"the-adt-in-ts","title":"TypeScript 里的 ADT","author":"eczn","time":"2023-07-25T13:38:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"hello-css-vars","title":"Hello CSS 变量","author":"eczn","time":"2023-08-12T10:32:11.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"type":"app","id":"css-matrix3d-calc","title":"CSS Matrix3D 中的矩阵运算","appTitle":"CSS Matrix","appIcon":"/tsxs-esm/matrix2x2.831ca9df4adfae73.svg","author":"eczn","time":"2023-08-17T16:00:00.000Z","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"latex-notes","title":"LaTeX 笔记","author":"eczn","time":"2023-10-20T16:00:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"ipod-spin-gesture","title":"iPod 转盘手势","author":"eczn","time":"2023-11-19T17:20:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"type":"app","id":"app-pinch","title":"Pinch 捏放手势","appTitle":"Pinch 捏放手势","appIcon":"/tsxs-esm/pinch.daef4e8852186e91.svg","author":"eczn","time":"2024-01-01T15:33:00.000Z","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"old-demos","type":"app","appTitle":"早期 DEMO 集","appIcon":"/tsxs-esm/demo-book.dc04159dd4134c99.svg","title":"早期 DEMO 集","author":"eczn","time":"2024-03-16T10:50:00.000Z","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"binary-complement-principle","title":"二进制补码的数学原理","author":"author","time":"2024-04-29T15:58:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"moonbit-start","title":"Moonbit, 启动","author":"eczn","time":"2024-05-01T03:33:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"parser-combinator","title":"Parser Combinator","author":"eczn","time":"2024-05-01T23:00:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"v8-asm-detail-of-inline-caches","title":"V8 Inline Caches 优化及其汇编细节","author":"eczn","time":"2024-06-29T23:49:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"typescript-52000-checker.ts","title":"TypeScript 52000+ 行的 checker.ts","author":"eczn","time":"2024-09-01T00:00:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"perlin-noise","title":"柏林噪声的原理和实现","author":"eczn","time":"2024-12-02T04:03:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},{"id":"review-2024","title":"24 年底的简单记录","author":"ecznlai","tags":[],"time":"2024-12-30T19:00:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"isDraft":false,"fileDeps":[],"wordCount":0}],"current":{"type":"tsx","meta":{"id":"three-body-emulator","title":"三体运动模拟器","time":"2021-06-16T10:33:00.000Z","author":"eczn","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},"tsxDistPath":"./three-body-emulator/index.blog.js","ssrContent":"<div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">三体运动没有解析解，这种遵循物理定律的混沌运动很适合用来做屏保，如:</div><div class=\"std-window mode-windowed\"><div class=\"std-window-menus\"><div class=\"std-window-title\"><span></span></div><div class=\"std-window-btns\"><div class=\"std-icon std-window-menu-btn\" style=\"overflow:hidden;border-radius:1em;box-sizing:border-box\"></div><div class=\"std-icon std-window-menu-btn\" style=\"overflow:hidden;border-radius:1em;box-sizing:border-box\"></div></div></div><div style=\"height:300px\" class=\"std-window-content\"><canvas style=\"display:block;margin:0 auto\" width=\"320\" height=\"300\"></canvas></div></div><div style=\"display:none;height:0px;background:#BBB\">placeholder</div><h1 id=\"point\" class=\"std-title --fontTitle\"><a href=\"#point\" class=\"markdownIt-Anchor\">#</a> 质点<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">将星球运动简化为质点，有二维坐标及速度向量，最后加上其质量:</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span>__NO_CODE__</pre></div><h1 id=\"position\" class=\"std-title --fontTitle\"><a href=\"#position\" class=\"markdownIt-Anchor\">#</a> 速度对坐标, 引力对速度<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">速度对坐标的影响比较容易处理将上面的定义的 PointStatic 结构进行 (p.x += p.dx) 即可, 而引力对速度的影响, 则要计算加速度 (f = ma) 以及展开后在二维上的分量进行累加才行</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">这里有个情况需要注意，因为是质点，所以距离近的时候力会瞬间增大到无穷导致 number 溢出或者除 0 出现的 NaN, 所以要做最小距离处理</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">具体实现如下</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span>__NO_CODE__</pre></div><h1 id=\"draw-and-multi-points\" class=\"std-title --fontTitle\"><a href=\"#draw-and-multi-points\" class=\"markdownIt-Anchor\">#</a> 绘图控制 &amp; 多质点<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span>__NO_CODE__</pre></div><h1 id=\"playground\" class=\"std-title --fontTitle\"><a href=\"#playground\" class=\"markdownIt-Anchor\">#</a> playground<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">调整参数控制, 建议保持动量和为 0, 不然会跑到画布之外</div><div><textarea style=\"font-family:consolas, Menlo;width:100%;height:300px\">[\n  {\n    &quot;x&quot;: 150,\n    &quot;y&quot;: 80,\n    &quot;m&quot;: 100,\n    &quot;dx&quot;: 6,\n    &quot;dy&quot;: 0\n  },\n  {\n    &quot;x&quot;: 150,\n    &quot;y&quot;: 150,\n    &quot;m&quot;: 100,\n    &quot;dx&quot;: -6,\n    &quot;dy&quot;: 0\n  },\n  {\n    &quot;x&quot;: 150,\n    &quot;y&quot;: 200,\n    &quot;m&quot;: 100,\n    &quot;dx&quot;: 0,\n    &quot;dy&quot;: 0\n  }\n]</textarea></div><div class=\"std-window mode-windowed\"><div class=\"std-window-menus\"><div class=\"std-window-title\"><span></span></div><div class=\"std-window-btns\"><div class=\"std-icon std-window-menu-btn\" style=\"overflow:hidden;border-radius:1em;box-sizing:border-box\"></div><div class=\"std-icon std-window-menu-btn\" style=\"overflow:hidden;border-radius:1em;box-sizing:border-box\"></div></div></div><div style=\"height:300px\" class=\"std-window-content\"><canvas style=\"display:block;margin:0 auto\" width=\"320\" height=\"300\"></canvas></div></div><div style=\"display:none;height:0px;background:#BBB\">placeholder</div>","props":{"codePointStatic":"// point-static.ts\nexport interface PointStatic {\n  /** 坐标 x */\n  x: number;\n  /** 坐标 y */\n  y: number;\n  /** 速度向量 x */\n  dx: number;\n  /** 速度向量 y */\n  dy: number;\n  /** 质量 */\n  m: number;\n}\n","codePoint":"// point.ts\nimport { PointStatic } from './point-static';\n\nexport class Point implements PointStatic {\n  public x!: number;\n  public y!: number;\n  public dx!: number;\n  public dy!: number;\n  public m!: number;\n\n  public constructor(data: PointStatic) {\n    Object.assign(this, data);\n  }\n\n  /** 当前速度对坐标的影响 */\n  public move() {\n    this.x += this.dx;\n    this.y += this.dy;\n  }\n\n  /**\n   * p 和 this 间的引力对 this 速度影响\n   * @param p 其他点\n   * @param g 引力常数\n   */\n  public effect(p: Point, g: number) {\n    const r = this.distance(p);\n\n    const distanceX = p.x - this.x;\n    const distanceY = p.y - this.y;\n\n    // f = ma 展开后可以得到 a = g * p.m / (r * r)\n    // 这个 a 是带方向的，它的方向跟 this -> p 练成的线的方向是一致的\n    // 根据这个来做 x y 方向的分量拆解得到 k 最后得到各分量 ax ay\n    const k = g * p.m / (r * r * r);\n    const ax = k * distanceX;\n    const ay = k * distanceY;\n\n    this.dx += ax;\n    this.dy += ay;\n  }\n\n  /** 求与 p1 的距离 */\n  private distance(p1: Point): number {\n    const y = this.y - p1.y;\n    const x = this.x - p1.x;\n    const yy = y * y;\n    const xx = x * x;\n    const rr = yy + xx;\n    // 最小距离\n    const min = 100;\n    if (rr <= (min * min)) return 100;\n    const r = Math.sqrt(rr);\n    return r;\n  }\n\n  /** 根据 m 给一个合适的半径 方便绘图 */\n  public getPointRadius(): number {\n    const r = Math.sqrt(this.m);\n    if (r <= 4) return 2; // 最小值 免得太小了看不到了\n    if (r >= 24) return 12; // 免得太大了\n    return r / 2;\n  }\n}\n","codeGravity":"// gravity.tsx\nimport { PointStatic } from './point-static';\nimport { Point } from './point';\n\nexport interface GravityOptions {\n  points: PointStatic[]; // 各个点的实例\n  g?: number; // 引力常数\n}\n\nexport class Gravity {\n  public $dom!: HTMLCanvasElement;\n  public c2d!: CanvasRenderingContext2D;\n  public g: number;\n  public points: Point[] = [];\n  public timer: ReturnType<typeof requestAnimationFrame> | null = null;\n  public drawLine = false;\n\n  public constructor(opts: GravityOptions) {\n    const { points, g } = opts;\n    this.g = g || 1;\n    this.initFromPoints(points);\n  }\n\n  public initFromPoints(points: PointStatic[]) {\n    this.points = points.map(p => new Point(p));\n  }\n\n  public addPoint(p: PointStatic) {\n    this.points.push(new Point(p));\n  }\n\n  public setDom($dom: HTMLCanvasElement) {\n    this.$dom = $dom;\n    const c2d = $dom.getContext('2d')!;\n    if (!c2d) throw new Error('no 2d context');\n    this.c2d = c2d;\n  }\n\n  public updatePointsInfo() {\n    this.points.forEach(p => {\n      this.points.forEach(otherP => {\n        if (otherP === p) return; // 排除自己\n        p.effect(otherP, this.g);\n      });\n    });\n\n    this.points.forEach(p => {\n      p.move();\n    });\n  }\n\n  public drawPoints() {\n    this.c2d.clearRect(0, 0, this.$dom.width, this.$dom.height);\n    this.c2d.fillStyle = 'rgba(77, 77, 77, 1)';\n    this.points.forEach(p => {\n      this.c2d.beginPath();\n      const r = p.getPointRadius();\n      this.c2d.arc(p.x, p.y, r, 0, Math.PI * 2);\n      this.c2d.fill();\n    });\n\n    if (this.drawLine) {\n      this.points.forEach((p, idx) => {\n        this.c2d.lineTo(p.x, p.y);\n      });\n\n      this.c2d.lineTo(this.points[0].x, this.points[0].y);\n      this.c2d.fillStyle = 'rgba(77, 77, 77, 0.3)';\n      this.c2d.fill();\n    }\n  }\n\n  public toggleDrawLine() {\n    this.drawLine = !this.drawLine;\n  }\n\n  public start = () => {\n    if (this.timer) return;\n    this.render();\n  };\n\n  public stop = () => {\n    if (!this.timer) return;\n    cancelAnimationFrame(this.timer);\n    this.timer = null;\n  };\n\n  public render = () => {\n    this.updatePointsInfo();\n    this.drawPoints();\n    this.timer = requestAnimationFrame(this.render);\n  };\n};"},"tocStack":[{"id":"point","level":1,"text":"质点"},{"id":"position","level":1,"text":"速度对坐标, 引力对速度"},{"id":"draw-and-multi-points","level":1,"text":"绘图控制 & 多质点"},{"id":"playground","level":1,"text":"playground"}]}}}