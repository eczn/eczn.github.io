{"code":0,"data":{"type":"tsx","meta":{"id":"v8-asm-detail-of-inline-caches","title":"V8 Inline Caches 优化及其汇编细节","author":"eczn","time":"2024-06-29T23:49:00.000Z","type":"article","appTitle":"","appIcon":"","intro":"未定义 intro","category":"未分类标题","cateIntro":"该分类暂无介绍 ~","imgs":[],"tags":[],"isDraft":false,"fileDeps":[],"wordCount":0},"tsxDistPath":"./v8-asm-detail-of-inline-caches/index.blog.js","ssrContent":"<div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">写在前面：前段时间工作重心在性能优化，着重看了 V8 相关的优化细节，尤其是 Inline Caches (ICs) 技术，后面依据这项技术将核心指标性能优化到原来的十倍，这里记录一下 ICs 相关细节，仅供参考</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><div class=\"std-inline-em\">超长文警告</div></div><h1 id=\"jit-performance\" class=\"std-title --fontTitle\"><a href=\"#jit-performance\" class=\"markdownIt-Anchor\">#</a> 解释器 + JIT 的性能比想象中的要好<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">解释器手写的 line-by-line 虚拟机执行流水线完全比不上 CPU 内部的指令流水线以及更为夸张的分支预测手段，因此我个人过去认为 C 至少比 JS 快 10 倍+，直到最近看了不少的 v8 benchmark 之后才对这块有所改观，目前的观点是：只要构造合适，V8 JIT 可以有媲美原生 AOT 的性能，当然也容易出现非常夸张的性能劣化。（这里当然是指 CPU 性能，内存性能肯定永远比不上裸机的）</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">回到 V8 的执行过程，它首先将代码编译为 AST，然后将 AST 编译为 bytecode 字节码并交给叫做 ignition 的解释器进行解释执行，并在「合适」的时候将这些字节码经由 TurboFan 编译为裸机能直接运行的机器汇编指令，这种边执行边编译的过程叫做 JIT。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">除此之外，引擎在运行期间还会持续收集调用反馈 feedback，并依据这些 feedback 进一步优化 JIT 的效果。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">举例来说，下图的 add 函数，在后面调用了非常多次后，引擎就可以合理的假设 (assumption) ——「add 接受的两个参数 “大概率” 都是整数」</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span><span class=\"token punctuation\">}</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1_000_000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">05</span>  <span class=\"token comment\">// 调用了非常多次后，引擎就可以得到一条重要信息：</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">06</span>  <span class=\"token comment\">// add 接受的两个参数 “大概率” 是整数</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">07</span>  <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">08</span><span class=\"token punctuation\">}</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">那么根据这样的假设就可以按这样的方式进行 JIT 优化 (伪代码): </div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token comment\">// 依据这个假设「add 接受的两个参数 “大概率” 都是整数」</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span><span class=\"token comment\">// 来将前面的 js add 优化编译为一个原生的函数实现: </span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>fn <span class=\"token function\">add_jit</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> int <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a 不是整数<span class=\"token punctuation\">)</span> goto 回滚到解释器运行<span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b 不是整数<span class=\"token punctuation\">)</span> goto 回滚到解释器运行<span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">05</span>  <span class=\"token comment\">// 执行汇编级别原生整数加法</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">06</span>  <span class=\"token keyword\">return</span> <span class=\"token constant\">X86_ASM_ADD</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">07</span><span class=\"token punctuation\">}</span></pre></div><h1 id=\"v8-runtime-call\" class=\"std-title --fontTitle\"><a href=\"#v8-runtime-call\" class=\"markdownIt-Anchor\">#</a> V8 内置 runtime 指令 --allow-natives-syntax<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">利用这个参数开启 v8 注入的 runtime call，帮助分析和调试 v8</div><div class=\"std-code\"><pre  class=\"prismjs bash rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token comment\"># node 下开启</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>$ <span class=\"token function\">node</span> --allow-natives-syntax\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span><span class=\"token comment\"># chrome 下开启</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>$ <span class=\"token function\">open</span> <span class=\"token parameter variable\">-a</span> Chromium <span class=\"token parameter variable\">--args</span> --js-flags<span class=\"token operator\">=</span><span class=\"token string\">\"--allow-natives-syntax\"</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">开启后可以在 js 用 % 开头的内置 runtime 调用来输出一些内容</div><div class=\"std-code\"><pre  class=\"prismjs js rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token operator\">%</span><span class=\"token function\">DebugPrint</span><span class=\"token punctuation\">(</span><span class=\"token number\">1234</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span><span class=\"token comment\">// node --allow-natives-syntax ./test.js</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span><span class=\"token comment\">// 会输出很多东西 ...</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">下面是一些常用指令</div><h2 id=\"%debugprint(something);\" class=\"std-title --fontTitle\">%DebugPrint(something);</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">可以打印对象在 v8 的内部信息，比如打印一个函数:</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:71.64%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/rt1.9ac7a9f7772ef731.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/rt1.9ac7a9f7772ef731.png\"/></div></div><h2 id=\"%getoptimizationstatus(fn);\" class=\"std-title --fontTitle\">%GetOptimizationStatus(fn);</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">获取函数当前的优化 status，后文会详细介绍:</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:42.04%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/rt2.c2e6f5a639cd8dd7.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/rt2.c2e6f5a639cd8dd7.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">对应的是 V8 源码里的这个枚举:</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:62.72%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/rt3.a2b9592062a7a988.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/rt3.a2b9592062a7a988.png\"/></div></div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:80.59%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/rt4.ad7421fe7990b175.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/rt4.ad7421fe7990b175.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">从开发视角来看，一个函数最佳的 status 应该是 81 也就是 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">00000000000001010001</div>:</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:14.25%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA4IAAACACAMAAABp9yfFAAACJVBMVEUYGSHr27Hl1a3q2rAtLjOYxsrp2a+KgnCCemm5rI+PhnO4uybn16/g0ao7ODikmYDj1K3Zy6Y1MzTYyqW/spOVjHdFQkCIgG64q46imH+flX29sJJAPTyBeWlpZFmCfGsxMDKHf21DQD7WyKN5cWI4NzdgW1JVUUvQwp/OwJ7CtZQrKS27rpCakHjIu5qypYusoYaFfWuupIguLS/g0KnSxKC1p4vczahZVU3Mv5zCtZaSiXTVxqKYjnl4cGFdV1A9Ojp0bl9iXVTi06zRxKBvZ1yCemozMTKnnYPdzqick3t8dWXGuZi2qYzbzKdlgIWWjXhTT0l+dmdeWlFOS0VKR0NSUlbLvZuqn4VuZltIRUE/PTxwal5oYVakm4FybF9CQ0pMSESXxclrZlllX1VRTUhMSUTDtpdUanG3uic/QCHKvJs4OSGVwcWAeGionYTJvJx1lpx/gSN6e3tHR0dFQj9oaiKQu7+GrrKNhXFgen9LS00sNT0jJy18oKU6R04yPEQ3OED3uy4fICeXmiQtKCKDqq6CpqtriI6XjXhaWlqHiiR3eSOOj49ra2tGV131QVJbVk+hpCVdXyGCg4aDe2phYWFBUFgoMDdXWSKMtLlOY2g2QUhFRyGur7GhoqJwkJWnqKnSoC2ytSRTVCExNCGYLzzCw8bAwcOqq6uTlJhmZ2vhPU7EOUazNkJdJTC4jSptViZBNyNOTyJyKTSjfSqEaCbbQJl1AAAWH0lEQVR42uzXz0sCQRwF8DflXio6FHQJOnjIS7cuQREYRAcPQeAlgmAIGReFOsSGuCqKeihQUFBDO4SkaEFE9Pe1+YOxdbURW5FlPred+Q5v9/DYXbjG0cEVnwxFTCJaYqxUxrAIpZShzOKwFGc5DAhTqv3ep70VMz3HEuirsipG4NEW1GAw+FAowEqoUgOXVuuVWhqcabauWm9+PSeTyfcPdH2+5fOvL/3JQuHeyIeI3SvfBr/y+84xwO099GBit94tAOLpdiWYmZ9obfvsMgAT670tQvbtu7MLQpbGpZsFfMdu8znXOClwrUaz2WhharyCYqIxY/gUXdnHSCkR0YyVDOyiBjsgwlnhjnRAFmGfdbIy9TnXOBjQLhra/1RBRVEYRMSoYqDoySp9JdhFXe6ACGeFO8+JZ4eQTdhn78g/9TmhlyA36wreKT/YUAVvYJ9QB4Q4K9xxFgkhC2uYb7rYnyBmXUHeOarx0VxMC9OwlolDkv5mFPB6FfNOH91ASZJmIDXqK1SSpNlI6S4TXRZQkiRJ+maffnuSCsM4jl/fczYcDFQQTLB/ipFiRcrADMr5b1qiI7JJWW2unA/aqrfRwx70fuM+B9JdsTs4s9bZ/Dxxv1231805O78rf1mpdKpSf2UZ0KIMKjt2EmAWdKe2I1eu/AdSMKPS73aiBy5uck/6mZyUc7mki/NgVuwnfbdhRBT7LPhObXkTcBotvcV+Q3BzC3FWqmFLcnhWrxdss8A7Q6i8/b449nbwdJkVfOTgy8rvRuGH9DzGEz8Vy8mgFQy+U5uN06W22G8ILoYnuRiq9H0e4IaIbRZwZ/ikXYz88eDp0ip4ChRba7U87f6f6C3pykFi6V0UHLGf9E1N3RXFNgu+U1uBZHbtaTuO2mK9IbgNiNfWV2EhTOkedOtimw29M5wVHD2A5H5mGhKDp0ur4CpkxKjF/vCJjhMZ9d/z+t/4mC9rZwGq4hn5NxV8AAXv9ZAKUarjlmJ+XWyz4XeGsYIJ3Jvm76HLtyGS9uZ5euvoy5x0rVcr1W1TOpWUE5iQixZn9ivpWlk6PmYyu9DIdKRECpCWjlmYN993c230yWqjmdInTX41YlwXY6n5YnfrYep4eWtZ9EwePe+ZVM9g22mc5BoLpT3x3GpuyFy0Ur1rQhNeiU9vsd/QihX85sYOxZh92Kh/rW5LV61Wa0k//ht8CWRDlIrtssz5dbHNht8ZwgpeI/JGPDkqQyTlHr6JlBhFjCmYUUkpwZJcsOFgOC9F5IxfPopkYU8Mh4iIRFh1AJxTfbIjhzHSPW482wTqeiZtem6oZ7DsNDJ48in/isd1wP+BX6BXFb3FfoNDWgwYO78P9sVzDGxKH6/9z28TyIcnGb262GbD7gxlBR2ypojFo/sFnCGS0sBp7O5WYLzbrPHStAvMqKR8grKcKwCN90Vw74h8jkbPIB/tuC4ShRMx6uBVEPLtI4iIOtnxoVj8eqGCR+PAVgJuq5m8nfbEoaWewbpTWuCmSytw0Gv5RGkeHPN/sLIjHrXFeoOu4HeIfMou15n6QwWvwbbIGBGHRHjSxboMPrOl8FbwJ3vn9tNEEMXh8+0k1ZIWC4iWS6oFC0iVixSUi1y8BAElgBIEQUNQX0jUFx/8E/yvZWdaWA52WNDErOn3UPrL2ZzpkPm6s9ukvYNxyxpymPhJFKMfavdMjp6UDdmyyCcDRZUUqxCNFUx/uD+El/pa6Ru01qxttQqmj8JjeKyOVHcvA4Zk0V6vw4KqnYi/qubg7ylZzBt3KfLcKTgiInl4IlLOAAPtO2eu9/wjaAXfw0GYeuZ8Crpej+QGXG0hk5wU1SV+zZeSq2AnUyITkP5xCCZ+kjrAC5Ef1ZV1HYoqKTLufFo4OELkA0xLyDhGL9E2EKm2WbcKjrkGlfMUvCZiQkcCRlXNUcqQKak5+HvO4U5O87B1vDWWTewAexlCstNKQT2CX8EuaBWHX8FX0CO9jMszSE6K6hK/5kvJVbCL9yKEDzKJiZ/kDJ9+vL3X1QUTIg9AQj5AUSVFyilIyKJ0wMt8+og22FdLtAXEMlhVsM2mKcx5Cj4OHzrDhzVVczyEPj0Hf8+r8ERClqjYIWZsguXwz9iLLCHPlIJqBL+CyzDzUSJ0d3dbJzX3oHsUMy93ITkpqkv8Wv2UZAV7GZV+uGGvYkz8JIqeXqrkRYaq9XUoqqSoYCIKTnHCgVqik3C7dpN6XiTltqrOb7+CTVX7snSqWk3p6TNz8PfsgG4JGSDlbsccy+MojU6it8h6BL+CYxmA1XY5jxdQSHFfpI1UclJUl/g1X0quglkOZNZNoISJn872YWl4eW0N0iLPSLkVB0WVFAMglvewGKb7NZrVEu2C7xLiNh2p6oL9CvNxFGyvp2ATDJ6dg1/B4cjbgZanxgF6i+wfQXdpnUoBBLvipwkCHtp3s1xyUlSX+DVfSq6CM1yRdfdR1i1M/KTabFBd35C2utjwGooqKdLQd6JgHup+dP0WCpETZ4rJ2qWC/ImCr+GhnsO5Cq7B5+oeIqinoOQwqot/hIBB1WV9JICM+JkFeCN2a56cFNUlfs2Xkqtgmgci8NaekUz8JBEi+8FHdnF1QE+YrkBRJcUCDJ4oOA39EqUEN8WxAsP2Sgta7D89Wz0nZtSR8RRUt2L0HPw9F2Cj2rytroKHGNXFP0LWval8OtWlF3YkpJzP5zvlN3QDD1zPe8lJUV3i13wpuQq2s2WXxvWfA2DiJ9VmorpUJu3iKjhTpQ2KKmkqmM/HCu7DoZwCRqRKiqfuBdNkE+tOyHF15IUUbIG+383B3/NdddQCpLWCPc/FEVBRXfwjzBC4TW5UwQew6bsj6qbQ4/YT/QlKEV3i13wpuQoWoCQyAJDFxE+qzSgcNovkgbQVi127d6SokmYDUitlme+FRbtnvV4WkZW2SbEEpAriuAeHJbkDxgnJ02ardUEdeREF87BcZw6+njIEX0XeBDCvFVxgaeOoy6MWGFZd/CNMQIfIVZyCg4cfRWQuhZFzFLwCLfNyE7JJSrK3vT0Cw9vbe77apXsmiazdCa7kp5rKj6cvkBQ5IICcW1y7QMYAFHXSdAIYsOeAsSwQBMCAWNoBY0yfiLRmcYw6Bd2AjMuZI7+YI1wcPK2gqskqYCwbag7enrKTAhO4bZBWsDYfsvqV+Ufotk/JOgW3gJwB7nsUdAxgMXOJShzjq126Z5LYg8IlkmanBeBhKUPeHpsBgj3ri0qaA6dW3qURY9PMrDhuLqWofgpXHgcIFsQpmH8J7kpSHznKMUMScEUkx7RVUNWkhRobag7eniLN9lBTO9F22b/2NFZ6FWCZGNOvzD+CbBigUrJdZPopIUG7OJojTmumAHL9yUrUML7apXsmikn4Gj/F/s7+nZUdlerTF612L8yu1z3wTkkcKV6J7O7JX0TPwU+5/m8uNPdt7G7GG0FP7/bpXy/Yl3jMzS4mMFni1jwp8d8SUh6CSlfT6/2ezQukf4tTsEGD/4SbBsfzC6SL0lCwQQPPd8d0bFWCINcXO/3zr8hpKNigwT8lw4Q0aNCgQYMGf5+r/GLvXnrSCMMojj+HSSoa2qDWShDalNRLJQoBNfVCTLyUFiyJaYwusF204NJVP4jfuDDzQvCZGWc6vZjOnF/YTAjs/gEm4T1pIaKwmCBRvDBBokcQnOBqpVKWf0HvOBAli1+CM8ALGVvvjLgbaXfGSqJE2HEgSpZwCW5h5LNoDYz1RAnecWCClHDhEpypVpeArWq1uuyV4GbV0RQlwo4DUbIEJ2gUgJwYOsGXv7HjQJRsQQl+XVi4cCdYujrb3tw51QmqtQSzwJBb21kVo7n46eSy1vPacVgcKojRz9/s1tpiG70LPyIphgISbAHz4kqwBceOTlCfrZLC3jaGTEztDGy3QTsO+7AdzMn9dyGKm4cT/AJsiyvBd+MNBJNgetmmElQLDANTAC5vcx0sBew4tEc7DrNqx4EobkYJvnf07yVYA3ZFJ6g3EBoALFtLJTi5wLAiIuUnyNzZ31Zbnr8Fm4E7Do/+pw0i+UsJwlGcSPBHDjgTnaBrA6GBkbxKUC8w5IEZMR48u/POf8eBKGbSyBWHPBI8ANbElaDZQDiaTHD/3FZXCeoFhhtYYkTecSCKmTQMV4JDqbo7QbOBYM3ui4S4HTNx1cGxGJF3HIhipp92eCV4Mni4EpzYQMh2AxJUV1l0xPjVHQcmSHHnkeDGsICGTtBYNRsI7gTXfRM8QEqM8DsOTJCSwfOOaDkFnHslaPrAhUpQrSWoeKaBZ2KE3nFggpRMdoKyAmR9E6zpBPVago6nDXMp9XA7DtfANBOkZHISlCvYt0IOu90pYK3b7crA883vInL3BJboBM1aQhFeCcq8k1Th7dJ4ZeGb347DB7PjwAQpmUyC0gFe6T8rXQLWcQbAhjvBAoBMBk89E+ynzCtNgguwHYkTrbHn7DhksgBqwgQpmabMUGDBgtWUjxg5VBsIdkfX4lBrCWqBYaB8g6Gt08g7DkRkNhD64uPoTVP89dunJQmhPtxxICIiIiIiIiIiIvqTilZRiCgKHmhP9P9jgkSRPMKmRDnyNoR+LrRKpSdEsRb2KN/8fMY6PitF24bQz4U1B7wWolgLmeA6bKme36nYTJDoZ3t3/txCGMdx/PvZHaUkFVqkKXVUqBZp0TrqqtY4Ghr3re5xU0fFXQSl7vu+mTHjNv4/z7FWso0kVWfyff2QzZMnx0/vWU3Mfn9jgj7AXb4qGzA6NhtC73GCjLUzQQ+ycsRhONCQNMHkOEHG2jdTYgGQR8IgfVnDzqEpOZPGB0M9SdgQCsnZECGhzWyI8tC8mbVlPVeMqh1Fzj0aN/sb3XrpwDkVeVWjSWuoLA4s4wRZ+ktppkS+GudgX1Q3C+MN6y/DxLMhDEizagBMdO7R0tgrJ04zIBkLov729HKCLO2lNFMiG1hL0kRAJQgULV0C0WPi2RAGsMQDoNYNDHDs0coCxaUv1TQEQHB1CWD69aVnPIECE5wgS3spzZQQ3fQkaZu6kwVk6ytWTEo8G8LASLkYRgRUO/Yknd5cPcfXHKonxgSJSk24S4nmmZwgS3uJZkrMkT1IuQApecA8leBoElwYk/hHCQPdiUyUyXvljj3N74LLL44NQBVJFTCJDlpvmMcJsrTXBd4uUsKZEj0AUkqsBHNJmgAzWYKT5I1P3oTiJjjWmpaUDwS92UIusJZGASQ1cIIs7aU0U2J81AXmp8oEgyTIUpIl2NWqzw1f7J6ddJVV83fraaTV9jxOkKW9JDMlikkqAPaTVGt9HZNH0i4VZPIEe8VNUH9ICSnFwIhvcqgWWSQN4gRZxvjRTIlz1u8HhWR9aaJ/lCBpDkAdSXABMJY0L0Calbx+AifIMkbCmRJ1QICE0UAPlaDbOie67NkQ7U3Q/ipGqwKGki3fuohpZ06QZSx7pkQNCVn60AvoqlaYp4OssGdD/ESCPaIGV68FdpOtEFhKQi4nyDLW95kSJfo/h27z02DA1EGiJkdNViq0Z0MUtjtBb8zQ3AKgoFSecIuWqH/wYqX4cP5pnmWuqJkSN4l6uqGVWwnCrDGBCtJ6yQdMU57TdpqCXpY4EozZU+8MU5kvT6lusfJ4TP0N0EoALhOcIMtcsTMlqLQCglFNOkFvEILoKPFsCEOe8TyoUgk69qiHvZhPUpkJaeJkEla5ABirZPOMMWXIYD9pWZhDtHIV/WqDqicPtRfL65YTY8zBTpAxlipOkLH0wgky9le5UEmMMcbY/4+vps1Ye3CCjKUXTpCxvyb5TIn28wUaqCN43gTLMKlcyjd/VpSxlJCB4fQjdbNsg/gyv4ylnGAJov18gpNg28gJMpZygtVlQjYwpkzqUIIjy7QZnCBjqSao+YECkjqUYCHPm2CsfTMlQqHlzgTndx1CUueuC0nqExpC+0cU7/bpBP29to0ckUPaWl9wWKAuboLLZ+fVLtk1mJT+oWk0OLuicqhzFWfeRHVlReV0TpClhyQJ+oBcciZoII8koDtJLmT7IA2Te8UGhKwpJPWCUtSzbYLDoeWqPQMTJkKqc6x43gRLb6nMlEie4Bhg7MgiFMs9ILdsG2CWyvOlOOYFxgJzrQS7+BUSgjCCM2dWAB4i63WBYsBwrHjeBEtvyWdKpJIgjKvi2LeL3FObVcBqcXDDXKivADxdJ2jxiVV5A0k+oEFHV6YvKDPNsYo/b2Ijz5tg6SHRTAkvEKTUEpxO9h5m6KNBNAXwkjAVWOJM0AbMtMem0SKgPHbF8yZYeusCbz8p0UyJ5AnW0PcEe3y/Gm8XYBpJszBGJ1g1TxlN0saDS4cXFACV6nUTSQJmx6543gRLb8lmSqSWYHFUgktIWg34ZTx9SSpGVpuvYwYVweLVX8DY7xmz4nkTLL0lmSlRm1qC1k5UPD5gLQWixsG0SdANzArMDoWAbMd7xqx43gTLDD+aKTEpboIlzh8lohKs/T51KQRsIqkIhjPBOsBHUpIEed4EywyJZko4E3RjPAkb4yfoIWk8TKJqYL71aK4jQdWoNC5JgjxvgmUme6aEp22CE2GQEIifIMaJQylQRLTC+llxFZDtTLASWKRaTZIgz5tgmen7TIkJjgRVPflE/fCDBGv6ykqxUv8NOJNooQFMdSZYLsLKIZqDZAnGnzexi3+aZ+ktaqZEf2eCfQG4XHDHT1CoMYEiEpZnAS4PgFHkTJA8ejCFJ0mCcedNGC6eN8HSXOxMCaEnMJws800AY/xAvpWgNyrB7DzAPnfm9IBgdiapF7CKbIvU1li/frVhBQ7kx6543gRjcUwbPIN+bHoh2UZvqOtN8e2vLvy5eROLeN4EY4wxxhhjjDHGGGOM/R8QgxhjCXGCjKUXTjBjnVgT1wn6dRo1+tNaGhvrqa3TexT6C+wP5wSZ7fHeaDcuWp5SXEebm5upne500o7QH7ajU6cd1NbWbgq128uXL6lj7A/nBJnt6b5o5y9ZHlFcT0RKlzM0wQviRQ+pg7Zzghns1InDixcfPnHKcRZcEW35+Vva61+XINXX1x/4xxLcSvQXEtSuc4IZ6sRiy4nYBHOiTT18Xutggk5nOUFOMNOtkfUdPixv18Qk2DPGisXaU2prc339PZHSMXFWu0/S/cYz9840br5DTg/EU5qbW8LHNsdL8HjLsXD4WMtxeVc88fa3U+UhcbjTEj5Tf/S+XpA41os3C4efHNEvPBtu1G95ROwc1y+7rA+3j9SHzx4iRX908gSbmh7ejbRupwuR1pdq60JrJNJ6YTtpn/dErkX23CXhblPTNfG61qamphckbW9qvdbadNp6onhYPBKJXFAPfPry7NmHj2Q5/erd21fvOcFMJ8+B8t+gp9Sd6ARHxxjQ+7DyNO5ZxXZPLI8esBdOh8SjLevk3pm2CYY7WY4R3RaHAyo2cScs2lWfcUC+Mwmy+M2dpDP6FKx2m63nt4jn67dpls/YYX/eZfXRjYkT1Pe2iMXza/JGrCPdLK0kiYeVa0T0vJvtmj4lKs/v2s98sUU+EBHJPTup6QjfXVHevOcEM9NX95f1s+5tbtMAAAAASUVORK5CYII=\"/></div></div><h2 id=\"%optimizefunctiononnextcall(fn);\" class=\"std-title --fontTitle\">%OptimizeFunctionOnNextCall(fn);</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">告诉 v8 下次调用主动触发优化函数 fn</div><h2 id=\"%hasfastproperties(obj);\" class=\"std-title --fontTitle\">%HasFastProperties(obj);</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">%HasFastProperties 可以用来打印对象是否是 Fast Properties 模式</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:45.71%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/delete.de302969ba532e37.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/delete.de302969ba532e37.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">后文会介绍这个 Fast Properties 和与之对立的 Slow Properties</div><h1 id=\"v8-structure\" class=\"std-title --fontTitle\"><a href=\"#v8-structure\" class=\"markdownIt-Anchor\">#</a> V8 基于 assumption 的汇编优化细节<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">那么，V8 是如何利用「合理的假设」来通过 TurboFan 将代码编译为汇编机器码的呢？我们先来看这个例子，一个 add(x,y) 函数，如果运行期间出现了多种类型的传参，那么会导致代码变慢：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:101.51%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/add_benchmark.84d28db7d234ebf2.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/add_benchmark.84d28db7d234ebf2.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">我们可以看到，L15 速度慢了非常多，比一开始的 66ms 慢了几倍，推测原因：</div><ol class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">1.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">一开始只会传数字的时候，V8 会假设这是数字加法，可以极致优化。（66 毫秒可以跑完）</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">2.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">L13 传入其他参数，上述假设会被推翻，此时打印一次优化状态可以看看出现了反优化，在 L13 执行的时候实际走的是 ignition 解释器去跑的。</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">3.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">执行 L15 for 循环走了足够多次后，turbofan 收集到足够的信息后会重新建立假设来做优化，不过这次的假设是「入参可能是 number 也可能是 string」—— 这意味着调用的时候要多判断入参类型是 string 还是 number 从而导致了最终的性能劣化 （一模一样的代码要 243 毫秒才跑完，慢了有三倍吧）</div></li></ol><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">那么，在汇编层面上，V8 如何区分 0xXXXX 是数字还是对象？—— V8 使用 Tagged Pointer 来表示 JS 里的值和引用，具体见下一节</div><h2 id=\"tagged-pointer\" class=\"std-title --fontTitle\">Tagged Pointer</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">对于 V8 里的 Tagged Pointer，首先它是 C/C++ 里通用的优化技术，不只在 V8 里有用，具体来说就是依据 pointer 自身的数值的某些位来决定 pointer 的行为，也就是说这类指针的特点是「其指针数值上的某些位有特殊含义」，比如在 v8 里，js 堆指针和 SMI 小整数类型（small intergers）是通过 Tagged Pointer 来表达和引用的，区别就在于最低一位是不是 0 来决定其指针类型：</div><div class=\"std-code\"><pre  class=\"prismjs bash rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token comment\"># 对象指针（32 位）：</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxx1\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span><span class=\"token comment\"># SMI 小整数（32 位）其中 xxx 部分为数值部分：</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span>xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxx0</pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">用 C 表达就是这样：</div><div class=\"std-code\"><pre  class=\"prismjs c rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span><span class=\"token keyword\">void</span> <span class=\"token function\">printTaggedPointer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>  <span class=\"token comment\">// 强转一下, 关注 p 本身的数值</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span>  <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> tp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">05</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">06</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tp <span class=\"token operator\">&amp;</span> <span class=\"token number\">0</span>b1<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>b0<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">07</span>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>\"p 是 SMI<span class=\"token punctuation\">,</span> 数值大小为 <span class=\"token number\">0</span>x<span class=\"token operator\">%</span>x \n<span class=\"line-numbers-rows\" style=\"user-select: none;\">08</span>\"<span class=\"token punctuation\">,</span> tp <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">09</span>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">10</span>  <span class=\"token punctuation\">}</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">11</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">12</span>  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>\"p 是堆对象指针<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span>x<span class=\"token operator\">%</span>x<span class=\"token operator\">></span> \n<span class=\"line-numbers-rows\" style=\"user-select: none;\">13</span>\"<span class=\"token punctuation\">,</span> tp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">14</span>  <span class=\"token comment\">// printObject(*p); // 假设有个方法可以打印堆对象</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">15</span><span class=\"token punctuation\">}</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">16</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">17</span><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">18</span>  <span class=\"token function\">printTaggedPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x1234</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// smi</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">19</span>  <span class=\"token function\">printTaggedPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">17</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// object</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">20</span>  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">21</span><span class=\"token punctuation\">}</span></pre></div><h2 id=\"利用-tagged-pointer-来验证假设\" class=\"std-title --fontTitle\">利用 Tagged Pointer 来验证假设</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">我为何要提到 Tagged Pointer ? 因为这跟底层汇编 codegen 密切相关，比如前面的 add_jit 里，V8 就是利用 Tagged Pointer 细节来做 codegen 来实现 JIT 优化的：</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token comment\">// 依据这个假设「add 接受的两个参数 “大概率” 都是整数」</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span><span class=\"token comment\">// 来将前面的 js add JIT 优化编译为一个原生的函数实现: </span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>fn <span class=\"token function\">add_jit</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> int <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a 最低位不是 <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> goto 回滚到解释器运行<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不是 0 则代表不是 SMI 整数</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b 最低位不是 <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> goto 回滚到解释器运行<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不是 0 则代表不是 SMI 整数</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">05</span>  <span class=\"token comment\">// 执行汇编级别原生整数加法</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">06</span>  <span class=\"token keyword\">return</span> <span class=\"token constant\">X86_ASM_ADD</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">07</span><span class=\"token punctuation\">}</span></pre></div><h2 id=\"assumption-被打破的时候不会-crash-/-硬件错误-/-段错误吗？\" class=\"std-title --fontTitle\">assumption 被打破的时候不会 crash / 硬件错误 / 段错误吗？</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">前面已经提过了，是可以通过合理的数据结构设计来在汇编的层面上区分入参的类型的，比如利用 Tagged Pointer 来区分整数 / 对象类型 ——</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">上述说法可能会比较含糊，我们可以具体看看打出来的汇编是咋样的来验证我们刚学的 Tagged Pointer，可以通过以下方式打印出优化后的 x86 汇编（m1 芯片的苹果电脑应该是 arm 汇编）</div><div class=\"std-code\"><pre  class=\"prismjs bash rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span>$ <span class=\"token function\">node</span> --print-opt-code <span class=\"token punctuation\">\\</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>       --allow-natives-syntax <span class=\"token punctuation\">\\</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>       --trace-opt <span class=\"token punctuation\">\\</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>       --trace-deopt <span class=\"token punctuation\">\\</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span>       ./a.js</pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">如下图所示，L19 ~ L22 其实就是在根据 Tagged Pointer 的性质来判断入参是不是 SMI，具体来说是 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">[rbx+0xf]</div> 与 0x1 做按位与操作（<div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">[rbx+0xf]</div> 是通过栈传递的参数，是 v8 里 js 的调用约定）如果结果是 0 则跳转 0x10b7cc34f 即后续的正常流程，否则走到 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">CompileLazyDeoptimizedCode</div> 走反优化流程，回滚用 ignition 字节码解释器去执行：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:66.23%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/test_x86_asm.89e77743e48f8594.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/test_x86_asm.89e77743e48f8594.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">另外我们也可以看到，核心逻辑对应到汇编也就一行，剩余的指令要么是 checkpoint 要么是 v8/js 的调用约定，在这么多冗余指令的情况下执行性能依然很快，可见 CPU 指令流水线效率比起 line-by-line 的解释器流水线要高得多了。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">而且，从汇编和伪码来看也能知道，如果 assumption 经常被打破，性能会变差，而且如果入参的类型太多也会导致 checkpoint / type-guard 的逻辑变复杂，因此也能解释前面 add(a, b) 为什么打破一次之后性能就不如一开始的性能了 —— 类型检查 checkpoint 逻辑会变得更复杂导致优化效率下降：</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token comment\">// 依据这个假设「add 接受的两个参数 “大概率” 都是整数」</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span><span class=\"token comment\">// 来将前面的 js add JIT 优化编译为一个原生的函数实现: </span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>fn <span class=\"token function\">add_jit_2</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> unknown<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> int <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a 最低位不是 <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> goto 回滚到解释器运行<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不是 0 则代表不是 SMI 整数</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b 最低位不是 <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> goto 回滚到解释器运行<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不是 0 则代表不是 SMI 整数</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">05</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">06</span>  <span class=\"token comment\">// 如果出现过 add('', '') 打破了先前的假设，那么后续就会多一条这样的检查了</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">07</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a 是字符串 <span class=\"token operator\">&amp;&amp;</span> b 是字符串<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token constant\">X86_ASM_STRING_CONCAT</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">08</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">09</span>  <span class=\"token comment\">// ... 其他 checkpoint 比如, boolean + boolean</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">10</span>  <span class=\"token comment\">// ... 总之传的类型越杂这里行数就越多 ...</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">11</span>  <span class=\"token comment\">// 而对于过于复杂的函数, V8 就不会开启 TurboFan 汇编优化了</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">12</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">13</span>  <span class=\"token comment\">// 执行汇编级别原生整数加法</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">14</span>  <span class=\"token keyword\">return</span> <span class=\"token constant\">X86_ASM_ADD</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">15</span><span class=\"token punctuation\">}</span></pre></div><h2 id=\"哪里可以打印所谓-feedback-？\" class=\"std-title --fontTitle\">哪里可以打印所谓 feedback ？</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">通过 %DebugPrint 可以看到</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:101.97%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/slot_smi.ec9d42f1322f2665.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/slot_smi.ec9d42f1322f2665.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">当打破这个 assumption 后，会变成 Any</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:102.41%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/slot_any.4e2c170b7733c303.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/slot_any.4e2c170b7733c303.png\"/></div></div><h2 id=\"多态-return-会导致优化效果打折吗？\" class=\"std-title --fontTitle\">多态 return 会导致优化效果打折吗？</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">不会, 如图:</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:113.40%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/union_return.084db03690b8c56c.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/union_return.084db03690b8c56c.png\"/></div></div><h2 id=\"feedback-slot-里的-monomorphic-是？\" class=\"std-title --fontTitle\">feedback slot 里的 monomorphic 是？</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">一共有三种，代表参数类型的复杂度: </div><ol class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">1.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">Monomorphic 单态：指参数的类型只有一种，不会变</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">2.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">Polymorphic 多态：指参数的类型有多种 (比较短的 union type)</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">3.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">Megamorphic 巨态：指参数的类型非常复杂 (非常长的 union type) </div></li></ol><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">根据前面提到的 checkpoint，上面三个 mono 的 checkpoint 最少，而最后的 mega 将会非常多，优化性能最差，或者 V8 干脆就不会对这类函数做更深度的机器码优化了（比如后文会提到的 ICs） </div><h2 id=\"turbofan-过程本身耗时怎么样？\" class=\"std-title --fontTitle\">TurboFan 过程本身耗时怎么样？</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">从 JS AST 编译到机器码也需要开销，毫秒级:</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:5.21%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/turbofan_cost.f24e6b19974a0902.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/turbofan_cost.f24e6b19974a0902.png\"/></div></div><h2 id=\"反优化太多次怎么办？\" class=\"std-title --fontTitle\">反优化太多次怎么办？</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">根据这篇文章 https://erdem.pl/2019/08/v-8-function-optimization 如果某个函数「反优化」超过 5 次后，v8 以后就不再会对这个函数做优化了，不过我无法复现他说的这个情况，可能是老版本的 v8 的表现，node16 不会这样，不管怎样只要 run 了足够多次都会 turbofanned，只是如果「曾经传的参数类型太 union typed」会导致优化效果出现非常大的折损</div><h2 id=\"什么时候会启动-tutbofan-？\" class=\"std-title --fontTitle\">什么时候会启动 TutboFan ？</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">前面我们已经知道了「运行足够多次」会触发优化，而这只是其中一种情况，具体可以参考 v8 里 ShouldOptimize 的实现，里面有详细定义何时启动优化：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:107.80%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/ShouldOptimize.8acade9438495bb6.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/ShouldOptimize.8acade9438495bb6.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">作为开发视角来看：</div><ol class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">1.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">L371 已经优化过的代码不会再优化</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">2.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">L375 这段逻辑决定是否启用 maglev*</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">3.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">L386 通过参数主动禁用/或者省电模式等这类不会优化 ( 比如 node --v8-options=&quot;--turbo_filter=xxxxx&quot; )</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">4.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">L394 运行足够多次才会优化 (还有个配置项 efficiency<div class=\"std-inline-em\">mode</div>delay_turbofan 配置延迟多久启动 turbofan）</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">5.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">L402 太长的函数不会优化</div></li></ol><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">备注：maglev 是去年 chrome v8 团队搞的新特性：编译层次优化，总的来说就是根据 feekback 对机器码的编译层次做精细控制来达到更好的优化效果，下图是 v8 团队发布的 benchmark 对比：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:65.96%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/maglevBenchmark.f018fce50a529d11.svg\"/></div></div><h1 id=\"v8-object-model\" class=\"std-title --fontTitle\"><a href=\"#v8-object-model\" class=\"markdownIt-Anchor\">#</a> V8 对象模型<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">本节开始是本文的重点部分，因为只有了解 V8 对象的内存构造，才能真正理解 V8 诸多优化的理由。</div><h2 id=\"c-语言的-struct-是怎么实现「点读」的-?\" class=\"std-title --fontTitle\">C 语言的 struct 是怎么实现「点读」的 ?</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">在正式进入之前，我们先看看 C 里面 struct 的「点读」是怎么做的:</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:65.11%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/c-point-read.cf8f22c4a79cd309.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/c-point-read.cf8f22c4a79cd309.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><div class=\"std-inline-em\">C 会将 struct 理解为一段连续的线性 buffer 结构</div>，并在上面根据字段的类型来划分好从下标的哪里到哪里是哪个字段（对齐），因此在编译 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">point.x</div> 的时候会改成 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">base+4</div> 的方式进行属性访问，如下图所示，时间复杂度是 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">O(1)</div> 的：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:34.52%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/memStructPoint.ed518ffad8316dc0.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/memStructPoint.ed518ffad8316dc0.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">也因此 C 里面没提供从字段 key 名的方式去取 struct value 的方法，也就是不支持 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">point[&#x27;x&#x27;]</div> 这样，需要你自己写 getter 才能实现类似操作 ——</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">这类根据 string value 来从对象取值的技术通常在现代编程语言里都是自带了的，通常称为反射，可以在运行时访问源码信息。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">但在 JS 里，对象是动态的，可以有任意多的 key-values，而且这些 kv 键值对还可能在运行时期间动态发生变化，比如我可以随时 p.xxx =123 又或者 delete p.xxx 去删掉它，这意味着一个 object 的 “shapes” 及其「内存结构」是无法被静态分析出来的，而且这种内存结构必然不是「定长固定」的，是需要动态 malloc 变长的。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">假设现在是 2008 年，你是 google 的工程师，正在 chrome v8 项目组开发，你会怎样设计 JS 的对象的内存结构？</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token comment\">// obj 的内存结构可以设计成怎样？</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">一眼丁真，开搞：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:40.35%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/memMaybe1.bc7bbb9c3acffc70.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/memMaybe1.bc7bbb9c3acffc70.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">一个 key 定义加一个值，然后将这个结构数组化就可以表达对象的 kv 结构，增加属性就在后面继续扩增，查找算法则是从头查到尾，时间复杂度为 O(n), 如下图所示这般：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:24.19%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/memMaybe2.c59db0ff0e2af055.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/memMaybe2.c59db0ff0e2af055.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">但是如果按这个设计，下面两个 obj 就会有重复的 key 定义内存消耗了：</div><div class=\"std-code\"><pre  class=\"prismjs ts rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">const</span> o1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">22</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// \"x\" 11 \"y\" 22</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span><span class=\"token keyword\">const</span> o2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> x<span class=\"token operator\">:</span> <span class=\"token number\">33</span><span class=\"token punctuation\">,</span> y<span class=\"token operator\">:</span> <span class=\"token number\">44</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// \"x\" 33 \"y\" 44</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>                            <span class=\"token comment\">// 会重复 \"x\" 和 \"y\"</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">好了就上面这样简单弄一下就搞出了好多问题了，从下面开始正式进入，V8 是怎么描述对象的，参见下文</div><h2 id=\"jsobject-与-named-properties-&amp;-indexed-elements\" class=\"std-title --fontTitle\">JSObject 与 named-properties &amp; indexed-elements</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">在 js 标准里 Array 是一类特殊的 Object，但出于性能考虑 V8 底层针对对象和数组的处理是不同的：</div><ul class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">所谓 indexed-elements 指的是数组元素（以数字下标作为 key）存储于 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*elements</div>，是一段线性内存空间，可以直接用下标直接访问，查找速度非常快</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">而其他的普通成员所谓 named-properties 则存储于 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*properties</div> 查找速度比较慢，需要遍历对比</div></li></ul><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">如下图所示，JSObject：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:54.65%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-03.ae87637a13f091cf.svg\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">在 V8 里：</div><ol class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">1.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">Array-indexed 的属性存储在 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*elements</div> 里，查找速度快；Named Properties 则存储在 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*properties</div> 里，查找速度慢</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">2.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">Properties / Elements 这两个结构可以是数组，但有时候也会变成字典（比如稀疏数组场景，线性内存空间就不够性能了）</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">3.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">每个 JSObject 都有一个 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*hiddenClass</div>, 用于保存对象的 Shapes</div></li></ol><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">嗯？对象的 Shapes？那是什么？</div><h2 id=\"对象的-shapes\" class=\"std-title --fontTitle\">对象的 Shapes</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">所谓对象的 shapes，其实就是对象上有什么 key，前面提到过 V8 的优化需要在运行时不断收集 feedback，比如当执行下面这段代码的时候，引擎就可以知道「obj 有两个 key，一个是 a 一个是 b」：</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>obj<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>obj<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token number\">124</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span><span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">V8 通过 Hidden Class 结构来记录 JSObject 在运行时的时候有哪些 key，也就是记录对象的 shapes，由于 JSObject 是动态的，后续也可以随意设置 obj.xxx = 123，也就是对象的 shapes 会变，也因此对象持有的 Hidden Class 会随着特定代码的运行而变化</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">Hidden Class 是比较学术的说法，在 V8 源码里的「工程命名」是 Map，在微软 Edge Chakra (edge) 里叫做 Types，在 JavaScriptCore (WebKit Safari) 里叫做 Structure，在 SpiderMonkey (FireFox) 里叫做 Shapes .... 总之各个主流引擎都有实现追踪「对象 shapes 变化」</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">后文可能会混淆上面几个用语，它们都是指 Hidden Class，用来描述对象的 shapes。</div><h2 id=\"hidden-class-descriptorarrays-与-in-object-properties\" class=\"std-title --fontTitle\">Hidden Class DescriptorArrays 与 in-object properties</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">前面提到除了 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*properties</div> 和 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*elements</div> 可以用来存储对象成员之外，JSObject 还提供了所谓 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">in-object properties</div> 的方式来存储对象成员，也就是将对象成员保存在 JSObject 自身上，并配合 Hidden Class 进行键值描述：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:68.66%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-04.c7ec5dff3a7bc878.svg\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">上图里 Hidden Class 里底下有个叫做 DescriptorArrays 的子结构，这个结构会记录对象成员 key 以及其对应存储的 in-object 下标，也就是上面的紫框。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">读到这里，或许你会问：</div><ol class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">1.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">为什么要这样，这样做能帮助提升性能么？别急，后文会扣回来。</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">2.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">什么时候用 in-object 什么时候用 *properties 存储，两者做的是同一件事，不会冲突吗？别急，后文会提。</div></li></ol><h2 id=\"变化中的-hidden-class\" class=\"std-title --fontTitle\">变化中的 Hidden Class</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">如果 Hidden Class 是静态的，那么这图就足够描述 Hidden Class 了：</div><div class=\"std-img-dynamic-wrapper --fontArticle\" style=\"width:50%\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:100.00%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-11.0ebe4fdc1ff2a78f.svg\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">但是对象的 shapes 会变，也因此对象持有的 Hidden Class 会随着特定代码的运行而变化，V8 使用了 Transition Chain，一种基于链表构造的方式来描述「变化中的 Hidden Class」：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:51.94%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-05.8f41d62f2eac3902.svg\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">备注：为了方便讨论，后文可能不会将 Hidden Class 画成链表，而是画成一起并且省略空对象的 shapes，另外 Hidden Class Node 上还有其他字段，相对不那么重要，就忽略了</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">由于链表的特性，显然可以比较容易地让具有相同 shapes 的对象能复用同一个 Hidden Class ，比如下面这个 case，o1 o2 均复用了地址为 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">0xABCD</div> 的 Hidden Class 节点：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:73.23%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-06.710bf7a56412ac08.svg\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">当出现不同走向的时候，此时会单独开一个 branch 来描述这种情况，此时 o1 和 o2 就不再一样了：</div><div class=\"std-img-dynamic-wrapper --fontArticle\" style=\"width:94%\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:89.05%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-06-2.1f18f088b1f33fed.svg\"/></div></div><h2 id=\"v8-对象模型总结\" class=\"std-title --fontTitle\">V8 对象模型总结</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><div class=\"std-inline-strong --fontTitle\">从前文的讨论，可以得到的结论：</div></div><ol class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">1.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">V8 使用 JSObject 来描述对象，上面有若干个字段（除了上面那些还有 prototype 原型链那些，相对不那么重要，就没画出）</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">2.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">V8 还使用 Tagged Pointer 来描述对象指针（前文有提）</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">3.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">named properties 成员存储在 *properties 里，可以为数组，也可以为字典</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">4.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">named properties 也可以存储在 in-object properties 里，可以动态增长。</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">5.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">数字下标成员存储在 *elements 里，可以为数组，也可以为字典（稀疏数组场景）</div></li></ol><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><div class=\"std-inline-strong --fontTitle\">悬而未决的问题：</div></div><ol class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">1.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">何时用 in-object properties 何时用 *properties ?</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-decimal\">2.</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">为什么看起来 Hidden Class 这套机制下属性查找依然是 O(n) 的操作？追踪对象的 shapes 意义在哪？</div></li></ol><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">请带着这两个问题到下一章 Inline Caches 继续阅读。</div><h1 id=\"v8-inline-caches\" class=\"std-title --fontTitle\"><a href=\"#v8-inline-caches\" class=\"markdownIt-Anchor\">#</a> V8 Inline Caches (ICs) 优化原理<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">引入 Hidden Class 后，为了读取某个成员，那不还得查一次 Hidden Class 拿到 in-object 的下标，这个过程不还是 O(n) 吗？</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">是的，如果事先不知道 JSObject 的 shapes 的情况下去读取成员确实是 O(n) 的，但前面我已经提过了：</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">V8 的诸多优化是基于 assumption 的，那么在已知 obj 的 Shapes 的情况下，你会怎么优化下面这个 distance 函数？</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:86.32%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-04-2.1b7960a3ec9ba150.svg\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">如此优化就将通过 key 访问成员的 O(n) 过程优化为 O(1) 按下标偏移直接读取了，这种优化手段就叫做 Inline Caches (ICs)，有点像 C 语言的 struct 将字段点读编译为偏移访问，只不过这个编译是 JIT 的，不是 C 那样 AOT 静态编译确定的，是 V8 在函数执行多次收集了足够多的 feedback 后实现的。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">你可能还会问：在调用优化后的 distance2 的时候具体要怎么确定传入的 p1 p2 的 shapes 是否有变化？还记得前面那个 0xABCD 吗？没错，编译后的汇编 checkpoint 就是直接判断传入对象的 hidden classs 指针数值是不是 0xABCD，如果不是就触发「反优化」兜底解释器模式运行即可。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">—— 怎么？感觉有点迷惑？ 下面这个实例将手把手展开 ICs 的真实场景以及汇编细节</div><h2 id=\"汇编实例：为什么静态的比动态的要好-?\" class=\"std-title --fontTitle\">汇编实例：为什么静态的比动态的要好 ?</h2><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">从前面 Inline Cache 的讨论中可以得知，必须要确定了访问的 key 才能做 ICs 优化，因此写代码的过程中，如有可能请尽量避免下面这样通过 key string 动态查找对象属性：</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span> key<span class=\"token operator\">:</span> string<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>  <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span><span class=\"token punctuation\">}</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">如果能明确知道 key 的具体值，此时建议写为：</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>obj<span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span> key<span class=\"token operator\">:</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">===</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">===</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span><span class=\"token punctuation\">}</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">即使确实不得不动态查询，但是你知道某个子 case 占了 99% 的调用次数，此时也可以这样优化：</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> key<span class=\"token operator\">:</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>  <span class=\"token comment\">// 为 'a' 的调用次数占了 99% 可以这样提前优化</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">===</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span>  <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span><span class=\"token punctuation\">}</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">静态和动态两种写法风格可能会有几倍甚至上百倍的差距，如果业务里有大几百万次的调用 test，优化后能省不少毫秒，比如下面这个「简化的服务发现」例子有近百倍的差距：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:53.50%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/serviceMap1.325a6d6606f3e722.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/serviceMap1.325a6d6606f3e722.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">原因是 s2.js 里那些属性访问都被 ICs 技术优化成 O(1) 访问了，速度很快 —— 为了探究内部的 ICs 相关汇编逻辑，尝试输出 serviecMap 的 Hidden Class (V8 里 hidden class 别名是 Map) 以及汇编源码：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:25.56%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/serviceMap2.86edf7605c2388d4.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/serviceMap2.86edf7605c2388d4.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">首先 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">%DebugPrint</div> 出 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">serviceMap</div> 的 Hidden Class 的物理地址，可以看到是 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">0x3a8d76b74971</div> 然后看后续编译优化的 arm machine code 是怎么利用这个地址实现 ICs 技术优化的：（我这会的电脑是 mac m1 因此是 arm 汇编，不是 x86 汇编）</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:136.46%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/serviceMap3.cd8dd44069e23b96.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/serviceMap3.cd8dd44069e23b96.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">可以看到，ICs 的 checkpoint 其实就是将 Hidden Map 的指针物理地址 inline cached 到汇编里了，如果 check 通过那么就可以基于这个假设直接将属性访问优化为 O(1) 的 in-object properties 访问了，这也是这个技术为什么叫做 Inline Cahce (ICs) 了</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">（这几乎是 V8 里效果最好的优化了，也因此部分 benchmark 里 nodejs 对象可能比 Java 对象还快，因为 Java 里有可能滥用反射导致对象性能非常差）</div><h2 id=\"fast-properties-和-slow-properties-\" class=\"std-title --fontTitle\">Fast Properties 和 Slow Properties </h2><div class=\"col-main\" style=\"display:flex;margin-bottom:16px\"><div style=\"width:76.9%;text-align:justify;box-sizing:border-box;padding-left:8px;padding-right:8px\"><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">如果知道 ICs 技术内涵的话，理解 Fast Properties 和 Slow Properties (或者称字典模式) 就不会有困难了。</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">右图描述了 JSObject 的主要构造：当把对象成员存储到 in-object properties 的时候，此时称对象是 Fast Properties 模式，这意味着对象访问 V8 会在合适的时候将其 Inline Cache 到优化后的汇编里； </div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">反之，当成员存储到 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*properties</div> 的时候，此时称为 Slow Properties，此时就不会对这类对象做 inline cache 优化了，此时对象访问性能最差（因为要遍历 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*properties</div> 字典<sup id=\"1\" class=\"std-footnote-ref\"><span class=\"std-ref-link __inactive\">[1]</span><span class=\"std-ref-warp\" style=\"height:4px\"></span><span class=\"std-ref-content __inactive\" style=\"width:0;left:0;clear:both;top:calc(\n              undefined -\n              ((undefined - undefined) / 2)\n          );height:0px\"><span>20250317 update: 这里有个错误，*properties 字段也可以是数组的、这种情况也能算是 Fast Properties，感谢<a href=\"https://github.com/Doctor-wu\" target=\"_blank\" style=\"background-color:#efe5df\" class=\"std-link --fontSansSerif  _line\" data-minimap-color=\"#efe5df\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/github.com?h=1998410146\" style=\"background-image:url(&quot;/get-favicon/github.com?h=1998410146&quot;)\"></span><span class=\"std-link-txt\">@Doctor-wu</span></a>的指正</span></span></sup><span style=\"position:absolute;width:100%;top:0%;left:0%;display:block\" class=\"PLEASE_IGNORE_ME\"></span>，通常慢几十到几百倍，取决于对象成员数量</div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">我们可以用 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">%HasFastProperties</div> 来打印对象是否是 Fast Properties 模式，如下图所示</div></div><div style=\"width:23%;text-align:justify;box-sizing:border-box;padding-left:8px;padding-right:8px\"><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:271.53%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-12.7b5b7ca05173aa9a.svg\"/></div></div></div></div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:45.71%\"><img class=\"std-img-dymanic-main r-link __mosaic __loading\" src=\"/tsxs-esm/delete.de302969ba532e37.png.mosaic.png\"/><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/delete.de302969ba532e37.png\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">delete 会将对象转为 slow properties 模式，为什么呢？因为 delete 带来的问题可太多了，缓存技术最怕的就是 delete，如图所示：</div><div class=\"std-img-dynamic-wrapper --fontArticle\"><div class=\"std-img-dynamic\" data-minimap=\"Rect\" style=\"padding-bottom:43.21%\"><div class=\"std-img-dymanic-main __texttip __loading\">loading...</div><img class=\"std-img-dymanic-main\" src=\"/tsxs-esm/v8-ics-09.0ef4c014988b490e.svg\"/></div></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">我拍脑子就能想到上面四个问题，要完整的确保 delete 的安全性可太难了，因此维护 delete 后的 hidden class 非常麻烦，V8 采取的方式是直接将 in-object 释放掉，然后将对象属性都复制存储到 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">*properties</div> 里了，以后这个对象就不再开启 ICs 优化了，此时这种退化后的对象就称为 slow properties (或者称字典模式)</div><h1 id=\"eof\" class=\"std-title --fontTitle\"><a href=\"#eof\" class=\"markdownIt-Anchor\">#</a> EOF<i data-minimap=\"Ignore\"> ↵ </i></h1><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">下面这些内容比较散，我简单列一下：</div><ul class=\"numbering-main\" data-minimap-color=\"#DDDDDD\"><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">把 V8 ICs 这套搞懂让我爽了快一个月 ... </div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">愈发鄙视动态写法了，比如我曾经喷过用 array.includes 来做这种语法糖，这种写法会让 ICs 失效的，性能我简单测了一下至少慢了五十倍：</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">===</span> <span class=\"token string\">'aa'</span> <span class=\"token operator\">||</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span>  key <span class=\"token operator\">===</span> <span class=\"token string\">'bb'</span> <span class=\"token operator\">||</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span>  key <span class=\"token operator\">===</span> <span class=\"token string\">'cc'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">03</span><span class=\"token comment\">// => 改写为: </span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">04</span><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'aa'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'bb'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'cc'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span></pre></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">这篇文章位于：<a href=\"/b/should-we-use-array-includes-for-condition-connection/\" target=\"_blank\" style=\"background-color:#e5dcdd\" class=\"std-link --fontSansSerif  _line\" data-minimap-color=\"#e5dcdd\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/eczn.github.io?h=-7297367980\" style=\"background-image:url(&quot;/get-favicon/eczn.github.io?h=-7297367980&quot;)\"></span><span class=\"std-link-txt\">可否用数组 includes 来取代条件集联判断</span></a></div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">字面量申请的空对象 V8 会额外预先分配一些空的 in-object，然后通过 <div class=\"std-inline-code\" data-minimap-color=\"#f5e9e9\">Slack Tracking 松弛追踪</div> 技术在合适的时候释放没有用到的空间 —— 为什么要预先分配？因为 V8 假设空对象后面都会增加属性上去</div><div class=\"std-code\"><pre  class=\"prismjs tsx rally-runner  \" ><span class=\"line-numbers-rows\" style=\"user-select: none;\">00</span><span class=\"token keyword\">const</span> o1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// o1 shallow size 为 28 </span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">01</span><span class=\"token keyword\">const</span> o2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> ggg<span class=\"token operator\">:</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">}</span>  <span class=\"token comment\">// o2 为 16</span>\n<span class=\"line-numbers-rows\" style=\"user-select: none;\">02</span><span class=\"token keyword\">const</span> o3 <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// o3 为 12</span></pre></div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">输出一个暴论：依据前文提到的 ICs 优化，原型链继承将会大大影响 prototype 上函数的 JIT 效率，尤其是子类有很多自己的属性的时候，而从前面的 add 函数可知，这种 case 下性能可能会慢好几倍 🐢</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">Safari 也有 JIT 也有 ICs 技术, 根据 ICs 优化原理写的代码很多程度上全平台通用 （其实主流 JS 引擎都实现了 ICs, 包括 FireFox）</div></li><li class=\"numbering-item\"><div class=\"numbering-marker numbering-marker-rect\"></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">其他代码建议看我授权发表在公司官号上的内容，那里详细一点 (这篇文章首发于公司内网): <a href=\"https://mp.weixin.qq.com/s/k3O8dkzT6zpoURg_6ny2ZQ\" target=\"_blank\" style=\"background-color:#eae0e2\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#eae0e2\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/mp.weixin.qq.com?h=13744155258\" style=\"background-image:url(&quot;/get-favicon/mp.weixin.qq.com?h=13744155258&quot;)\"></span><span class=\"std-link-txt\">极速优化：十倍提升JS代码运行效率的技巧</span></a></div></li></ul><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\">最后的最后，总之参考了大量资料，感谢互联网以及 GPT, 让我得以站在巨人的肩膀上研究 V8 及其 JIT 优化细节，不敢说 100% 精通，但现在如果让我从头写一个 js jit 编译器我大概是能知道要怎么写了: </div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://v8.dev/docs/hidden-classes\" target=\"_blank\" style=\"background-color:#dce3e7\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#dce3e7\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/v8.dev?h=-2409480448\" style=\"background-image:url(&quot;/get-favicon/v8.dev?h=-2409480448&quot;)\"></span><span class=\"std-link-txt\">Maps (Hidden Classes) in V8 · V8</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://v8.dev/blog/fast-properties\" target=\"_blank\" style=\"background-color:#e5dfec\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#e5dfec\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/v8.dev?h=10914635342\" style=\"background-image:url(&quot;/get-favicon/v8.dev?h=10914635342&quot;)\"></span><span class=\"std-link-txt\">Fast properties in V8 · V8</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc/edit#slide=id.g5499b9c42_01170\" target=\"_blank\" style=\"background-color:#f2f4e5\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#f2f4e5\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/docs.google.com?h=-6454129217\" style=\"background-image:url(&quot;/get-favicon/docs.google.com?h=-6454129217&quot;)\"></span><span class=\"std-link-txt\">Google Docs - TurboFan TechTalk presentation</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://github.com/v8blink/v8-JavaScript-Documents\" target=\"_blank\" style=\"background-color:#f6ebee\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#f6ebee\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/github.com?h=-4402280732\" style=\"background-image:url(&quot;/get-favicon/github.com?h=-4402280732&quot;)\"></span><span class=\"std-link-txt\">GitHub - v8blink/v8-JavaScript-Documents</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://v8.dev/blog/pointer-compression\" target=\"_blank\" style=\"background-color:#f6e1e8\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#f6e1e8\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/v8.dev?h=5711278048\" style=\"background-image:url(&quot;/get-favicon/v8.dev?h=5711278048&quot;)\"></span><span class=\"std-link-txt\">Pointer Compression in V8 · V8</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://blog.towavephone.com/browser-working-principle-v8/\" target=\"_blank\" style=\"background-color:#e6f4e0\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#e6f4e0\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/blog.towavephone.com?h=11226762332\" style=\"background-image:url(&quot;/get-favicon/blog.towavephone.com?h=11226762332&quot;)\"></span><span class=\"std-link-txt\">V8工作原理 - 女王控的博客</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://www.zhihu.com/zvideo/1408790742785916928\" target=\"_blank\" style=\"background-color:#f8e5eb\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#f8e5eb\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/www.zhihu.com?h=5209804783\" style=\"background-image:url(&quot;/get-favicon/www.zhihu.com?h=5209804783&quot;)\"></span><span class=\"std-link-txt\">Google开源的JavaScript引擎——V8 - 知乎</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf\" target=\"_blank\" style=\"background-color:#dee1e0\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#dee1e0\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/www.jfokus.se?h=15420500754\" style=\"background-image:url(&quot;/get-favicon/www.jfokus.se?h=15420500754&quot;)\"></span><span class=\"std-link-txt\">Escape Analysis in V8</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://webkit.org/blog/10308/speculation-in-javascriptcore/\" target=\"_blank\" style=\"background-color:#eeecef\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#eeecef\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/webkit.org?h=-2304275555\" style=\"background-image:url(&quot;/get-favicon/webkit.org?h=-2304275555&quot;)\"></span><span class=\"std-link-txt\">Speculation in JavaScriptCore | WebKit</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://v8.dev/blog/slack-tracking\" target=\"_blank\" style=\"background-color:#dde8e1\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#dde8e1\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/v8.dev?h=-2228524022\" style=\"background-image:url(&quot;/get-favicon/v8.dev?h=-2228524022&quot;)\"></span><span class=\"std-link-txt\">Slack tracking in V8 · V8</span></a></div><div class=\"std-para --fontArticle\" data-minimap-color=\"#CCCCCC\"><a href=\"https://docs.google.com/document/d/11T2CRex9hXxoJwbYqVQ32yIPMh0uouUZLdyrtmMoL44/edit#heading=h.6jz9dj3bnr8t\" target=\"_blank\" style=\"background-color:#e9e8ed\" class=\"std-link --fontSansSerif  _block\" data-minimap-color=\"#e9e8ed\"><span class=\"std-link-icon r-link\" data-src=\"/get-favicon/docs.google.com?h=-19552573841\" style=\"background-image:url(&quot;/get-favicon/docs.google.com?h=-19552573841&quot;)\"></span><span class=\"std-link-txt\">Ignition Design Doc - Google Docs</span></a></div>","props":{},"tocStack":[{"id":"jit-performance","level":1,"text":"解释器 + JIT 的性能比想象中的要好"},{"id":"v8-runtime-call","level":1,"text":"V8 内置 runtime 指令 --allow-natives-syntax"},{"id":"%debugprint(something);","level":2,"text":"%DebugPrint(something);"},{"id":"%getoptimizationstatus(fn);","level":2,"text":"%GetOptimizationStatus(fn);"},{"id":"%optimizefunctiononnextcall(fn);","level":2,"text":"%OptimizeFunctionOnNextCall(fn);"},{"id":"%hasfastproperties(obj);","level":2,"text":"%HasFastProperties(obj);"},{"id":"v8-structure","level":1,"text":"V8 基于 assumption 的汇编优化细节"},{"id":"tagged-pointer","level":2,"text":"Tagged Pointer"},{"id":"利用-tagged-pointer-来验证假设","level":2,"text":"利用 Tagged Pointer 来验证假设"},{"id":"assumption-被打破的时候不会-crash-/-硬件错误-/-段错误吗？","level":2,"text":"assumption 被打破的时候不会 crash / 硬件错误 / 段错误吗？"},{"id":"哪里可以打印所谓-feedback-？","level":2,"text":"哪里可以打印所谓 feedback ？"},{"id":"多态-return-会导致优化效果打折吗？","level":2,"text":"多态 return 会导致优化效果打折吗？"},{"id":"feedback-slot-里的-monomorphic-是？","level":2,"text":"feedback slot 里的 monomorphic 是？"},{"id":"turbofan-过程本身耗时怎么样？","level":2,"text":"TurboFan 过程本身耗时怎么样？"},{"id":"反优化太多次怎么办？","level":2,"text":"反优化太多次怎么办？"},{"id":"什么时候会启动-tutbofan-？","level":2,"text":"什么时候会启动 TutboFan ？"},{"id":"v8-object-model","level":1,"text":"V8 对象模型"},{"id":"c-语言的-struct-是怎么实现「点读」的-?","level":2,"text":"C 语言的 struct 是怎么实现「点读」的 ?"},{"id":"jsobject-与-named-properties-&-indexed-elements","level":2,"text":"JSObject 与 named-properties & indexed-elements"},{"id":"对象的-shapes","level":2,"text":"对象的 Shapes"},{"id":"hidden-class-descriptorarrays-与-in-object-properties","level":2,"text":"Hidden Class DescriptorArrays 与 in-object properties"},{"id":"变化中的-hidden-class","level":2,"text":"变化中的 Hidden Class"},{"id":"v8-对象模型总结","level":2,"text":"V8 对象模型总结"},{"id":"v8-inline-caches","level":1,"text":"V8 Inline Caches (ICs) 优化原理"},{"id":"汇编实例：为什么静态的比动态的要好-?","level":2,"text":"汇编实例：为什么静态的比动态的要好 ?"},{"id":"fast-properties-和-slow-properties-","level":2,"text":"Fast Properties 和 Slow Properties "},{"id":"eof","level":1,"text":"EOF"}]}}