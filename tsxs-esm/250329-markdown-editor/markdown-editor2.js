System.register(['react', 'rally/@@'], (function (exports) {
  'use strict';
  var React, Code;
  return {
    setters: [function (module) {
      React = module.default;
    }, function (module) {
      Code = module.Code;
    }],
    execute: (function () {

      exports('default', SourceMarkdownEditor);

      // loaded by rollup-plugin-rally-query-resolve
      const lang = 'tsx';
      const source = "import React from 'react';\n\n\nfunction getSelectionForce() {\n  const s = window.getSelection();\n  if (s) return s;\n  throw new Error('get Selection Error !');\n}\n\nlet MEditorCounter = 0;\nexport class MEditor {\n  public id: string;\n  public state = MEditor.State();\n  public selection: MEditor.Selection = null;\n  private root: HTMLElement;\n  public constructor() {\n    this.id = `meditor-${MEditorCounter++}`\n    this.root = document.createElement('div');\n    this.root.id = this.id;\n    this.root.className = `meditor`\n    this.root.contentEditable = 'true';\n    this.root.addEventListener('keydown', this.onKeyPress, { capture: true });\n  }\n\n  private getEditorContainer = () => {\n    return document.getElementById(this.id)!;\n  }\n\n  public onSelectionChange = () => {\n    console.log('@@@ onselection changed');\n    const browserSelection = getSelectionForce()\n    if (MEditor.Utils.hasChild(this.getEditorContainer(), browserSelection.anchorNode)) {\n      this.selection = MEditor.getSelection(browserSelection);\n    }\n  }\n\n  public onKeyPress = (ev: KeyboardEvent) => {\n    // if (!this.selection) return console.log('@@ onKeyPress on no selection');\n    console.log('@@ onKeyPress', ev.key, ev.keyCode);\n    switch (ev.key) {\n      case 'Backspace': {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n        this.deleteText();\n        return;\n      }\n      case 'Ctrl': case 'Control':\n      case 'Shift':\n      case 'Meta':\n      case 'CapsLock':\n      case 'Tab':\n      case 'Escape':\n      case 'Alt': {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n        return\n      }\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowRight':\n      case 'ArrowLeft': {\n        // ev.preventDefault();\n        // ev.stopImmediatePropagation();\n        return;\n      }\n      case 'Enter': {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n        this.pressEnter();\n        return;\n      }\n      case ' ': {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n        this.pressSpace()\n        return;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopImmediatePropagation();\n    this.insertText(ev.key);\n  }\n\n  public insertText = (text: string) => {\n    if (MEditor.Selection.isCaret(this.selection)) {\n      // insert text\n      const { blockIndex, offset } = this.selection;\n      const block = this.state.blocks[blockIndex];\n      const newContent = block.content.slice(0, offset) + text + block.content.slice(offset)\n      block.content = newContent;\n      this.selection.offset += text.length;\n      this.render();\n      this.restore();\n    }\n  }\n\n  public deleteText = () => {\n    if (MEditor.Selection.isCaret(this.selection)) {\n      const { blockIndex, offset } = this.selection;\n      const block = this.state.blocks[blockIndex];\n      // 此时要删除行\n      if (block.content.length === 0 && blockIndex >= 1) {\n        this.selection.offset = this.state.blocks[blockIndex - 1].content.length + 1;\n        this.selection.blockIndex -= 1;\n        this.state.blocks.splice(blockIndex, 1);\n      }\n\n      const newContent = block.content.slice(0, offset - 1) + block.content.slice(offset)\n      block.content = newContent;\n      this.selection.offset -= 1;\n      if (this.selection.offset <= 0) this.selection.offset = 0;\n      this.render();\n      this.restore();\n    }\n  }\n\n  public pressEnter() {\n    if (MEditor.Selection.isCaret(this.selection)) {\n      const { blockIndex, offset } = this.selection;\n      const block = this.state.blocks[blockIndex];\n      const newBlock = MEditor.Block.Paragraph(block.content.slice(offset));\n      block.content = block.content.slice(0, offset);\n      this.state.blocks.splice(blockIndex + 1, 0, newBlock);\n      this.selection.offset = 0;\n      this.selection.blockIndex = blockIndex + 1;\n      this.render();\n      this.restore();\n    }\n  }\n\n  public pressSpace() {\n    if (MEditor.Selection.isCaret(this.selection)) {\n      const block = this.state.blocks[this.selection.blockIndex];\n      let level = 0\n      if (block.content[level] === '#') {\n        if (block.content.startsWith('#')) level = 1;\n        if (block.content.startsWith('##')) level = 2;\n        if (block.content.startsWith('###')) level = 3;\n        if (block.content.startsWith('####')) level = 4;\n        if (block.content.startsWith('#####')) level = 5;\n        if (block.content.startsWith('######')) level = 6;\n\n        const newBlock = MEditor.Block.Header(level, block.content.replace('#'.repeat(level), '').trimStart());\n        this.state.blocks[this.selection.blockIndex] = newBlock;\n        this.selection.offset = 0;\n        this.render();\n        this.restore();\n      } else {\n        return this.insertText(' ');\n      }\n    }\n  }\n\n  public render() {\n    if (!this.root) return console.error('no root mounted');\n    const blockNodes = this.state.blocks.map((block, blockIndex) => {\n      const dom = document.createElement('div');\n      dom.dataset.blockIndex = `${blockIndex}`;\n\n      if (MEditor.Block.isHeader(block)) {\n        dom.className = `meditor-block meditor-block-header _level-${block.level}`;\n        dom.appendChild(new Text(block.content))\n      }\n\n      if (MEditor.Block.isParagraph(block)) {\n        dom.className = `meditor-block meditor-block-paragraph`;\n        dom.appendChild(new Text(block.content))\n      }\n\n      return dom;\n    }).filter(e => !!e) as HTMLElement[];\n    this.root.replaceChildren(...blockNodes);\n  }\n\n  private getBlockTextNode(blockIndex: number) {\n    const block = this.root.children[blockIndex];\n    return block.childNodes[0];\n  }\n\n  public restore() {\n    const browerSelection = getSelectionForce();\n    browerSelection.removeAllRanges();\n    if (MEditor.Selection.isCaret(this.selection)) {\n      const range = document.createRange();\n      const blockTextNode = this.getBlockTextNode(this.selection.blockIndex);\n      range.setStart(blockTextNode, this.selection.offset);\n      range.setEnd(blockTextNode, this.selection.offset);\n      browerSelection.addRange(range);\n    }\n  }\n\n  public mount(container: HTMLElement) {\n    this.render();\n    container.appendChild(this.root);\n    document.addEventListener('selectionchange', this.onSelectionChange);\n  }\n\n  public unmount() {\n    document.removeEventListener('selectionchange', this.onSelectionChange);\n    this.root.removeEventListener('keydown', this.onKeyPress, { capture: true });\n  }\n}\n\nexport namespace MEditor {\n  export namespace Utils {\n    export function findParentBlockNode(node?: Node | null) {\n      if (!node) return null;\n      if (node instanceof HTMLElement) {\n        const blockIndex = Number(node.dataset.blockIndex);\n        if (typeof blockIndex === 'number' && !Number.isNaN(blockIndex)) {\n          return { blockIndex, node }\n        }\n      }\n      return findParentBlockNode(node.parentNode);\n    }\n  \n    export function hasChild(parent: HTMLElement, node: Node | null) {\n      let current: Node | null = node;\n      while (current) {\n        if (current === parent) return true;\n        current = current.parentNode;\n      }\n      return false;\n    }\n  }\n\n  export type Block = (\n    | Block.Header\n    | Block.Paragraph\n  );\n  export namespace Block { // Adt, 相当的模板, 其实应该编程语言自动生成构造器的\n    export interface Header { type: 'Header', level: number, content: string; }\n    export function isHeader(x?: any): x is Header {\n      return x && x.type === 'Header';\n    }\n    export function Header(level: number, content: string): Header {\n      return { type: 'Header', level, content, }\n    }\n\n    export interface Paragraph { type: 'Paragraph', content: string }\n    export function isParagraph(x?: any): x is Paragraph {\n      return x && x.type === 'Paragraph';\n    }\n    export function Paragraph(content: string): Paragraph {\n      return { type: 'Paragraph', content }\n    }\n  }\n\n  export type Selection = (\n    | null\n    | Selection.Caret\n  );\n  export namespace Selection { // Adt, 相当的模板, 其实应该编程语言自动生成构造器的\n    export type Caret = { type: 'caret', blockIndex: number, offset: number };\n    export function isCaret(selection: Selection): selection is Caret {\n      return !!(selection && selection.type === 'caret')\n    }\n    export function Caret(blockIndex: number, offset: number): Caret {\n      return { type: 'caret', blockIndex, offset }\n    }\n  }\n\n  export function getSelection(browserSelection: globalThis.Selection): Selection {\n    if (browserSelection.type === `Caret`) {\n      const result = Utils.findParentBlockNode(browserSelection.anchorNode);\n      if (result) {\n        return Selection.Caret(result.blockIndex, browserSelection.anchorOffset);\n      }\n    }\n    return null;\n  }\n\n  export interface State {\n    blocks: Block[];\n  }\n\n  export function State(): State {\n    return {\n      blocks: [\n        Block.Header(1, 'hello,world'),\n        Block.Paragraph('你好世界'),\n      ],\n    }\n  }\n}\n\nexport function MarkdownEditor() {\n  const ref = React.createRef<HTMLDivElement>();\n  React.useEffect(() => {\n    // for debug\n    if (!ref.current) return;\n    const editor = new MEditor();\n    editor.mount(ref.current);\n    (window as any).MEditor = MEditor;\n    (window as any).editor = editor;\n    return () => {\n      editor.unmount();\n    }\n  }, []);\n\n  return <>\n    <div className=\"meditor-wrapper\" ref={ref} />\n  </>;\n}\n";
      function SourceMarkdownEditor(props) {
        return React.createElement(Code, { lang, source, ...props, });
      }

    })
  };
}));
