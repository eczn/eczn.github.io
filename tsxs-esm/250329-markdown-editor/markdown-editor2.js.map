{"version":3,"file":"markdown-editor2.js","sources":["../../../src/tsxs/250329-markdown-editor/markdown-editor.tsx?code"],"sourcesContent":["// loaded by rollup-plugin-rally-query-resolve\nimport React from 'react';\nimport { Code } from 'rally/@@';\nconst lang = 'tsx';\nconst source = \"import React from 'react';\\n\\n\\nfunction getSelectionForce() {\\n  const s = window.getSelection();\\n  if (s) return s;\\n  throw new Error('get Selection Error !');\\n}\\n\\nlet MEditorCounter = 0;\\nexport class MEditor {\\n  public id: string;\\n  public state = MEditor.State();\\n  public selection: MEditor.Selection = null;\\n  private root: HTMLElement;\\n  public constructor() {\\n    this.id = `meditor-${MEditorCounter++}`\\n    this.root = document.createElement('div');\\n    this.root.id = this.id;\\n    this.root.className = `meditor`\\n    this.root.contentEditable = 'true';\\n    this.root.addEventListener('keydown', this.onKeyPress, { capture: true });\\n  }\\n\\n  private getEditorContainer = () => {\\n    return document.getElementById(this.id)!;\\n  }\\n\\n  public onSelectionChange = () => {\\n    console.log('@@@ onselection changed');\\n    const browserSelection = getSelectionForce()\\n    if (MEditor.Utils.hasChild(this.getEditorContainer(), browserSelection.anchorNode)) {\\n      this.selection = MEditor.getSelection(browserSelection);\\n    }\\n  }\\n\\n  public onKeyPress = (ev: KeyboardEvent) => {\\n    // if (!this.selection) return console.log('@@ onKeyPress on no selection');\\n    console.log('@@ onKeyPress', ev.key, ev.keyCode);\\n    switch (ev.key) {\\n      case 'Backspace': {\\n        ev.preventDefault();\\n        ev.stopImmediatePropagation();\\n        this.deleteText();\\n        return;\\n      }\\n      case 'Ctrl': case 'Control':\\n      case 'Shift':\\n      case 'Meta':\\n      case 'CapsLock':\\n      case 'Tab':\\n      case 'Escape':\\n      case 'Alt': {\\n        ev.preventDefault();\\n        ev.stopImmediatePropagation();\\n        return\\n      }\\n      case 'ArrowUp':\\n      case 'ArrowDown':\\n      case 'ArrowRight':\\n      case 'ArrowLeft': {\\n        // ev.preventDefault();\\n        // ev.stopImmediatePropagation();\\n        return;\\n      }\\n      case 'Enter': {\\n        ev.preventDefault();\\n        ev.stopImmediatePropagation();\\n        this.pressEnter();\\n        return;\\n      }\\n      case ' ': {\\n        ev.preventDefault();\\n        ev.stopImmediatePropagation();\\n        this.pressSpace()\\n        return;\\n      }\\n    }\\n\\n    ev.preventDefault();\\n    ev.stopImmediatePropagation();\\n    this.insertText(ev.key);\\n  }\\n\\n  public insertText = (text: string) => {\\n    if (MEditor.Selection.isCaret(this.selection)) {\\n      // insert text\\n      const { blockIndex, offset } = this.selection;\\n      const block = this.state.blocks[blockIndex];\\n      const newContent = block.content.slice(0, offset) + text + block.content.slice(offset)\\n      block.content = newContent;\\n      this.selection.offset += text.length;\\n      this.render();\\n      this.restore();\\n    }\\n  }\\n\\n  public deleteText = () => {\\n    if (MEditor.Selection.isCaret(this.selection)) {\\n      const { blockIndex, offset } = this.selection;\\n      const block = this.state.blocks[blockIndex];\\n      // 此时要删除行\\n      if (block.content.length === 0 && blockIndex >= 1) {\\n        this.selection.offset = this.state.blocks[blockIndex - 1].content.length + 1;\\n        this.selection.blockIndex -= 1;\\n        this.state.blocks.splice(blockIndex, 1);\\n      }\\n\\n      const newContent = block.content.slice(0, offset - 1) + block.content.slice(offset)\\n      block.content = newContent;\\n      this.selection.offset -= 1;\\n      if (this.selection.offset <= 0) this.selection.offset = 0;\\n      this.render();\\n      this.restore();\\n    }\\n  }\\n\\n  public pressEnter() {\\n    if (MEditor.Selection.isCaret(this.selection)) {\\n      const { blockIndex, offset } = this.selection;\\n      const block = this.state.blocks[blockIndex];\\n      const newBlock = MEditor.Block.Paragraph(block.content.slice(offset));\\n      block.content = block.content.slice(0, offset);\\n      this.state.blocks.splice(blockIndex + 1, 0, newBlock);\\n      this.selection.offset = 0;\\n      this.selection.blockIndex = blockIndex + 1;\\n      this.render();\\n      this.restore();\\n    }\\n  }\\n\\n  public pressSpace() {\\n    if (MEditor.Selection.isCaret(this.selection)) {\\n      const block = this.state.blocks[this.selection.blockIndex];\\n      let level = 0\\n      if (block.content[level] === '#') {\\n        if (block.content.startsWith('#')) level = 1;\\n        if (block.content.startsWith('##')) level = 2;\\n        if (block.content.startsWith('###')) level = 3;\\n        if (block.content.startsWith('####')) level = 4;\\n        if (block.content.startsWith('#####')) level = 5;\\n        if (block.content.startsWith('######')) level = 6;\\n\\n        const newBlock = MEditor.Block.Header(level, block.content.replace('#'.repeat(level), '').trimStart());\\n        this.state.blocks[this.selection.blockIndex] = newBlock;\\n        this.selection.offset = 0;\\n        this.render();\\n        this.restore();\\n      } else {\\n        return this.insertText(' ');\\n      }\\n    }\\n  }\\n\\n  public render() {\\n    if (!this.root) return console.error('no root mounted');\\n    const blockNodes = this.state.blocks.map((block, blockIndex) => {\\n      const dom = document.createElement('div');\\n      dom.dataset.blockIndex = `${blockIndex}`;\\n\\n      if (MEditor.Block.isHeader(block)) {\\n        dom.className = `meditor-block meditor-block-header _level-${block.level}`;\\n        dom.appendChild(new Text(block.content))\\n      }\\n\\n      if (MEditor.Block.isParagraph(block)) {\\n        dom.className = `meditor-block meditor-block-paragraph`;\\n        dom.appendChild(new Text(block.content))\\n      }\\n\\n      return dom;\\n    }).filter(e => !!e) as HTMLElement[];\\n    this.root.replaceChildren(...blockNodes);\\n  }\\n\\n  private getBlockTextNode(blockIndex: number) {\\n    const block = this.root.children[blockIndex];\\n    return block.childNodes[0];\\n  }\\n\\n  public restore() {\\n    const browerSelection = getSelectionForce();\\n    browerSelection.removeAllRanges();\\n    if (MEditor.Selection.isCaret(this.selection)) {\\n      const range = document.createRange();\\n      const blockTextNode = this.getBlockTextNode(this.selection.blockIndex);\\n      range.setStart(blockTextNode, this.selection.offset);\\n      range.setEnd(blockTextNode, this.selection.offset);\\n      browerSelection.addRange(range);\\n    }\\n  }\\n\\n  public mount(container: HTMLElement) {\\n    this.render();\\n    container.appendChild(this.root);\\n    document.addEventListener('selectionchange', this.onSelectionChange);\\n  }\\n\\n  public unmount() {\\n    document.removeEventListener('selectionchange', this.onSelectionChange);\\n    this.root.removeEventListener('keydown', this.onKeyPress, { capture: true });\\n  }\\n}\\n\\nexport namespace MEditor {\\n  export namespace Utils {\\n    export function findParentBlockNode(node?: Node | null) {\\n      if (!node) return null;\\n      if (node instanceof HTMLElement) {\\n        const blockIndex = Number(node.dataset.blockIndex);\\n        if (typeof blockIndex === 'number' && !Number.isNaN(blockIndex)) {\\n          return { blockIndex, node }\\n        }\\n      }\\n      return findParentBlockNode(node.parentNode);\\n    }\\n  \\n    export function hasChild(parent: HTMLElement, node: Node | null) {\\n      let current: Node | null = node;\\n      while (current) {\\n        if (current === parent) return true;\\n        current = current.parentNode;\\n      }\\n      return false;\\n    }\\n  }\\n\\n  export type Block = (\\n    | Block.Header\\n    | Block.Paragraph\\n  );\\n  export namespace Block { // Adt, 相当的模板, 其实应该编程语言自动生成构造器的\\n    export interface Header { type: 'Header', level: number, content: string; }\\n    export function isHeader(x?: any): x is Header {\\n      return x && x.type === 'Header';\\n    }\\n    export function Header(level: number, content: string): Header {\\n      return { type: 'Header', level, content, }\\n    }\\n\\n    export interface Paragraph { type: 'Paragraph', content: string }\\n    export function isParagraph(x?: any): x is Paragraph {\\n      return x && x.type === 'Paragraph';\\n    }\\n    export function Paragraph(content: string): Paragraph {\\n      return { type: 'Paragraph', content }\\n    }\\n  }\\n\\n  export type Selection = (\\n    | null\\n    | Selection.Caret\\n  );\\n  export namespace Selection { // Adt, 相当的模板, 其实应该编程语言自动生成构造器的\\n    export type Caret = { type: 'caret', blockIndex: number, offset: number };\\n    export function isCaret(selection: Selection): selection is Caret {\\n      return !!(selection && selection.type === 'caret')\\n    }\\n    export function Caret(blockIndex: number, offset: number): Caret {\\n      return { type: 'caret', blockIndex, offset }\\n    }\\n  }\\n\\n  export function getSelection(browserSelection: globalThis.Selection): Selection {\\n    if (browserSelection.type === `Caret`) {\\n      const result = Utils.findParentBlockNode(browserSelection.anchorNode);\\n      if (result) {\\n        return Selection.Caret(result.blockIndex, browserSelection.anchorOffset);\\n      }\\n    }\\n    return null;\\n  }\\n\\n  export interface State {\\n    blocks: Block[];\\n  }\\n\\n  export function State(): State {\\n    return {\\n      blocks: [\\n        Block.Header(1, 'hello,world'),\\n        Block.Paragraph('你好世界'),\\n      ],\\n    }\\n  }\\n}\\n\\nexport function MarkdownEditor() {\\n  const ref = React.createRef<HTMLDivElement>();\\n  React.useEffect(() => {\\n    // for debug\\n    if (!ref.current) return;\\n    const editor = new MEditor();\\n    editor.mount(ref.current);\\n    (window as any).MEditor = MEditor;\\n    (window as any).editor = editor;\\n    return () => {\\n      editor.unmount();\\n    }\\n  }, []);\\n\\n  return <>\\n    <div className=\\\"meditor-wrapper\\\" ref={ref} />\\n  </>;\\n}\\n\";\nexport default function(props) {\n  return React.createElement(Code, { lang, source, ...props, });\n};"],"names":[],"mappings":";;;;;;;;;;;;;MAAA;MAGA,MAAM,IAAI,GAAG,KAAK,CAAC;MACnB,MAAM,MAAM,GAAG,k4SAAk4S,CAAC;MACn4S,6BAAQ,CAAC,KAAK,EAAE;MAC/B,EAAE,OAAO,KAAK,CAAC,aAAa,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,KAAK,GAAG,CAAC,CAAC;MAChE,CAAC;;;;;;;;"}